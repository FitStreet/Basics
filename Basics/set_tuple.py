"=====================Кортежи============="
# кортеж - неизменяемый, индексируемый, итерируеемый, упорядоченный тип данных, предназначенный дляхранения любых данных в определенном порядке.

tuple1 = (1,2,3,4, 'hello', 'world', [1,2], {'a': 'b'}, False, None)
tuple1[0] # 1
tuple1[4][2] # 'l'

"===============================Методы кортежей================="

# count считает кол-во принятого элемента в кортеже

tuple1 = (1,2,3,4,5,1,2,3,3,2)
print(tuple1.count(1)) # 2
print(tuple1.count(1)) # 3
print(tuple1.count(0)) # 0 если не находит элемент выводит 0

# index - возвращает индекс первого попавшегося элемента

tuple1 = (1,2,3,4,5,1,2,3,3,2)
print(tuple1.index(5)) # 4 находит первый попавшийся заданный элемент и выводит его индекс
# print(tuple1.index(5, 6, 8)) # ValueError так как этого элемента нет в заданном нами диапозоне первое число которое мы искали, второе и третье диапозон поиска, третье цисло не включается в диапозон.
print(tuple1.index(1, 4, 8)) # 5

"==========================Множества====================="
# мнежество - изменяемый, неупорядоченный, неиндексируемый, итерируемый, преднызначенный для хранения уникальных данных (множества могут хранить только неизменяемые типы данных)
set_ = {1,2,3,4,5} # {,,,}
a = {}
print(type(a)) # dict

set_ = set() # {} - множества
set_ = {'hello', 1, 2, 'hello'}
print(set_) # {'hello', 1, 2} or {1, 2, 'hello'}если 2 одинаковых элемента будет выводится один из них каждый раз по разному
#print(set[0]) # Error множества не индексируются

print('hello' in set_) # True
print('hell' in set_) # False

list_ = [1,2,3,4,5,6,12,12,1,1,12]
list_ = list(set(list_)) # [1,2,3,4,5,6,12] отсортирует список по возрастанию без повторетий

"================Методы множеств================"

# add - добавляет элемент в set, принимает только одно значение если такой элемент цже есть ничего не поменяется
set_ = {1, 2, 3}
set_.add(4)
set_.add('a')
print(set_) # 1,2,3,4,'a' or 'a', 1, 2, 3, 4

# FIFO First In First Out
# LIFO Last In First Out

# pop - удаляет элемент рандомно(в питон 3.8 по принципу FIFO)
set_ = {'asdf', 1, 2, 3}
popped = set_.pop()
print(set_, popped)# {'asdf', 2, 3, 4} 1

# remove - удаляет элемент по значению
set_ = {'asdf', 1, 2, 3}
set_.remove(1)
print(set_) # {2, 3, 'asdf'}
set_.remove('asdf')
print(set_) # {2, 3}
# set.remove(7) # KeyError

# intersection - находит пересечение между множеством и другими коллекциями
#(&)
set1 = {1,2,3,4}
set2 = {3,4,5,6}
set2 = list(set2)
print(set1.intersection(set2)) # {3,4} может сравнивать любые коллекции
# print(set1 & set2) # Error так можно сравнить только множества

# difference - находит отличия относительно первого сета
#(-)
set1 = {1,2,3,4}
set2 = {3,4,5,6}
set2 = list(set2)
set1.difference(set2) # {1,2} находит отличия первого от второго
# set2.difference(set1) # {5,6}
# print(set1 - set2) # Error

# symmetric_difference - находит все отдичия между сетами
set1 = {1,2,3,4}
set2 = {3,4,5,6}
print(set1.symmetric_difference(set2)) # {1, 2, 5, 6}


# symmetric_difference_update - обновит set1
set1 = {1,2,3,4}
set2 = {3,4,5,6}

print(set1.symmetric_difference_update(set2)) # 1, 2, 5, 6
print(set1)

# discard - удаляет элемент по значению, если такого элемента нет в множестве не выдает ошибку

set1 = {1,2,3,4}
discarded = set1.discard(2)
print(set1, discarded) # {1,3,4}

# узнать что делают методы - union, issubset.




